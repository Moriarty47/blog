import{_ as i,M as n,p as r,q as p,Q as e,t as a,N as o,V as c,a0 as t}from"./framework-5411b43d.js";const h={},u=t('<h3 id="介绍项目的难点" tabindex="-1"><a class="header-anchor" href="#介绍项目的难点" aria-hidden="true">#</a> 介绍项目的难点</h3><h3 id="let-var-const-有什么区别" tabindex="-1"><a class="header-anchor" href="#let-var-const-有什么区别" aria-hidden="true">#</a> let var const 有什么区别</h3><h3 id="你知道哪些-http-头部" tabindex="-1"><a class="header-anchor" href="#你知道哪些-http-头部" aria-hidden="true">#</a> 你知道哪些 http 头部</h3><h3 id="怎么和服务器保持连接" tabindex="-1"><a class="header-anchor" href="#怎么和服务器保持连接" aria-hidden="true">#</a> 怎么和服务器保持连接</h3><h3 id="http-请求跨域问题-你都知道哪些解决跨域的方法" tabindex="-1"><a class="header-anchor" href="#http-请求跨域问题-你都知道哪些解决跨域的方法" aria-hidden="true">#</a> http 请求跨域问题，你都知道哪些解决跨域的方法</h3><h3 id="webpack-怎么优化" tabindex="-1"><a class="header-anchor" href="#webpack-怎么优化" aria-hidden="true">#</a> webpack 怎么优化</h3><h3 id="你了解哪些请求方法-分别有哪些作用和不同" tabindex="-1"><a class="header-anchor" href="#你了解哪些请求方法-分别有哪些作用和不同" aria-hidden="true">#</a> 你了解哪些请求方法，分别有哪些作用和不同</h3><h3 id="你觉得-typescript-和-javascript-有什么区别" tabindex="-1"><a class="header-anchor" href="#你觉得-typescript-和-javascript-有什么区别" aria-hidden="true">#</a> 你觉得 TypeScript 和 JavaScript 有什么区别</h3><h3 id="typescript-你都用过哪些类型" tabindex="-1"><a class="header-anchor" href="#typescript-你都用过哪些类型" aria-hidden="true">#</a> TypeScript 你都用过哪些类型</h3><h3 id="typescript-中的-type-和-interface-有什么区别" tabindex="-1"><a class="header-anchor" href="#typescript-中的-type-和-interface-有什么区别" aria-hidden="true">#</a> TypeScript 中的 type 和 interface 有什么区别</h3><h3 id="react-怎么优化" tabindex="-1"><a class="header-anchor" href="#react-怎么优化" aria-hidden="true">#</a> React 怎么优化</h3><h3 id="算法题-合并乱序区间" tabindex="-1"><a class="header-anchor" href="#算法题-合并乱序区间" aria-hidden="true">#</a> 算法题：合并乱序区间</h3><h3 id="vue-的-diff-算法" tabindex="-1"><a class="header-anchor" href="#vue-的-diff-算法" aria-hidden="true">#</a> Vue 的 diff 算法</h3><p>当组件创建和更新时，vue 均会执行内部的 update 函数，该函数在内部调用 render 函数生成虚拟 dom 树，组件会指向新树，然后 vue 将新旧两树进行对比，找到差异点，最终更新到真实 dom。</p>',14),l=t('<p>在判断两个节点是否相同时，vue 是通过虚拟节点的 key 和 tag 来进行判断的。</p><blockquote><p>首先对根节点进行对比：</p><ul><li><p>相同，将旧节点关联的真实 <code>dom</code> 的引用挂载到新节点上，根据需要更新属性到真实 <code>dom</code> ，接着再对比其子节点数组；</p><ul><li><p>对比子节点数组时，vue 对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做是为了尽可能复用真实 <code>dom</code> ，尽量少的销毁和创建真实 <code>dom</code> 。</p><ul><li><p>相同，则进入和根节点一样的对比流程;</p></li><li><p>不同，则移动真实 <code>dom</code> 到合适的位置。</p></li></ul></li></ul></li><li><p>不相同，则按照新节点的信息递归创建所有真实 <code>dom</code> ，同时挂载到对应的虚拟节点上，然后移除掉旧 <code>dom</code> 。</p></li></ul></blockquote><h4 id="diff-时机" tabindex="-1"><a class="header-anchor" href="#diff-时机" aria-hidden="true">#</a> diff 时机</h4><p>当组件创建时，以及依赖的属性或数据变化时，会运行一个函数，该函数会做两件事：</p><ul><li>运行 <code>_render</code> 函数，生成一棵新的虚拟 <code>dom</code> 树(<code>vnode tree</code>)；</li><li>运行 <code>_update</code> 函数，传入虚拟 <code>dom</code> 树的根节点，对比新旧两棵树，完成对真实 <code>dom</code> 的更新。</li></ul>',5),f=e("pre",{class:"language-javascript"},[e("code",null,[e("span",{class:"token keyword"},"function"),a(),e("span",{class:"token function"},"Vue"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),a(),e("span",{class:"token punctuation"},"{"),a(`
  `),e("span",{class:"token comment"},"// other code"),a(`
  `),e("span",{class:"token keyword"},"const"),a(),e("span",{class:"token function-variable function"},"updateComponent"),a(),e("span",{class:"token operator"},"="),a(),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),a(),e("span",{class:"token operator"},"=>"),a(),e("span",{class:"token punctuation"},"{"),a(`
    `),e("span",{class:"token keyword"},"this"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"_update"),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"this"),e("span",{class:"token punctuation"},"."),a("_render"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),a(),e("span",{class:"token comment"},"// diff过程"),a(`
  `),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},";"),a(`
  `),e("span",{class:"token keyword"},"new"),a(),e("span",{class:"token class-name"},"Watcher"),e("span",{class:"token punctuation"},"("),a("updateComponent"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),a(`
  `),e("span",{class:"token comment"},"// other code"),a(`
`),e("span",{class:"token punctuation"},"}"),a(`
`)])],-1),k=t('<h4 id="update函数作用" tabindex="-1"><a class="header-anchor" href="#update函数作用" aria-hidden="true">#</a> <code>_update</code>函数作用</h4><p><code>_update</code> 函数接收一个 <code>vnode</code> 参数，即新生成的虚拟 <code>dom</code> 树，同时， <code>_update</code> 函数通过当前组件的 <code>_vnode</code> 属性，拿到旧的虚拟 <code>dom</code> 树。 <code>_update</code> 函数首先会给组件的 <code>_vnode</code> 属性重新赋值，让它指向新树。</p>',2);function _(m,v){const d=n("CodeLink"),s=n("CodeTool");return r(),p("div",null,[u,e("p",null,[a("对比差异的过程即为 diff，vue 在内部通过一个叫 patch 的函数完成该过程。 在对比时"),o(d,{to:"diff-时机"},{default:c(()=>[a("(diff 时机)")]),_:1}),a("，vue 采用深度优先、逐层比较的方式进行对比。")]),l,o(s,{class:"language-javascript no-win-ctrl","data-ext":"js",fullscreen:"undefined",steps:"undefined",action:"undefined",winCtrl:"false",async:"undefined",content:"function%20Vue()%20%7B%0A%20%20%2F%2F%20other%20code%0A%20%20const%20updateComponent%20%3D%20()%20%3D%3E%20%7B%0A%20%20%20%20this._update(this._render)%3B%20%2F%2F%20diff%E8%BF%87%E7%A8%8B%0A%20%20%7D%3B%0A%20%20new%20Watcher(updateComponent)%3B%0A%20%20%2F%2F%20other%20code%0A%7D%0A",ext:"javascript"},{default:c(()=>[f]),_:1}),k])}const b=i(h,[["render",_],["__file","QA.html.vue"]]);export{b as default};
