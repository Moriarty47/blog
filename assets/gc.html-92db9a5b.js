import{_ as a,p as e,q as r,a0 as i}from"./framework-5411b43d.js";const c={},l=i('<h2 id="javascript-垃圾回收-garbage-collection" tabindex="-1"><a class="header-anchor" href="#javascript-垃圾回收-garbage-collection" aria-hidden="true">#</a> JavaScript 垃圾回收(Garbage Collection)</h2><p>通常情况下，垃圾回收分为 <strong>手动回收</strong> 和 <strong>自动回收</strong> 两种策略。</p><h3 id="调用栈中的数据回收" tabindex="-1"><a class="header-anchor" href="#调用栈中的数据回收" aria-hidden="true">#</a> 调用栈中的数据回收</h3><p>JavaScript 引擎会通过向下移动 ESP(记录当前执行状态的指针)来销毁该函数保存在栈中的执行上下文。</p><h3 id="堆中的数据回收" tabindex="-1"><a class="header-anchor" href="#堆中的数据回收" aria-hidden="true">#</a> 堆中的数据回收</h3><p>在 V8 引擎中，会把堆分为 <strong>新生区</strong>(存放生存时间短的对象) 和 <strong>老生区</strong>(存放生存时间久的对象) 两个区域。V8 使用两个不同的垃圾回收器进行高效垃圾回收。主垃圾回收器负责老生区的垃圾回收，副垃圾回收器负责新生区的垃圾回收。后续垃圾回收使用 GC 缩写代替。</p><p>主副垃圾回收器有共同的执行 GC 流程：</p><ol><li>标记空间中的活动对象(正在使用的对象)与非活动对象(可进行 GC 的对象)；</li><li>在所有标记完成之后，回收所有非活动对象的占用内存(即统一清理所有被标记为可回收的对象)；</li><li>内存整理，一般情况下，频繁回收对象，内存会产生大量不连续的空间(即内存碎片)，此时如果需要分配较大连续内存时，有可能出现内存不足的情况。因此需要整理内存碎片。</li></ol><h4 id="新生区中的垃圾回收" tabindex="-1"><a class="header-anchor" href="#新生区中的垃圾回收" aria-hidden="true">#</a> 新生区中的垃圾回收</h4><p>新生区中使用 Scavenge 算法。将新生区空间对半划分为 <em>对象(from)区域</em> 和 <em>空闲(to)区域</em>，新加入的对象会存放到对象区域，当对象区域快写满时，执行一次 GC 操作。</p><p>副垃圾回收器会把存活的对象复制到空闲区域，同时对它们进行排序，相当于完成内存整理操作。复制完成后，将对象区域和空闲区域角色互换，即原来的空闲区域变为对象区域，原来的对象区域变为空闲区域，这样就完成了整个 GC 操作。角色互换的操作让新生区的两块区域可以无限重复使用。</p><p>为了执行效率，一般新生区的空间设置不大，为 1~8 M 左右，因此很容易被存活的对象装满整个区域，此时 V8 引擎引入了 <strong>对象晋升</strong> 策略，即经过两次 GC 依然存活的对象，”晋升“到老生区。</p><h4 id="老生区中的垃圾回收" tabindex="-1"><a class="header-anchor" href="#老生区中的垃圾回收" aria-hidden="true">#</a> 老生区中的垃圾回收</h4><p>老生区中使用 Mark-Sweep 算法，即标记-清除算法。</p><p>从一组根元素开始，递归遍历根元素，在遍历过程中，能到达的元素被标记为活动对象，不可到达的元素被标记为可回收对象，标记完成后进行清除过程。</p><p>清除完成后，会产生大量不连续的内存碎片，碎片过多会导致分配较大连续内存时内存不足，此时是使用 Mark-Compact 即标记-整理算法，标记过程与前面相同，标记完成后，让所有存活的对象都向一端移动，然后清理掉边界以外的内存，从而清理出连续的内存块。</p><h4 id="全停顿行为" tabindex="-1"><a class="header-anchor" href="#全停顿行为" aria-hidden="true">#</a> 全停顿行为</h4><p>JavaScript 运行在主线程上，执行 GC 算法时，需要将正在执行的 JavaScript 脚本暂停，待 GC 完成后在恢复脚本执行。这种行为即为全停顿。</p><p>新生区的 GC，基本不会有全停顿，但老生区占用空间大，执行 GC 可能会长时间占用主线程，此时就会造成页面卡顿现象。</p><p>V8 采用 Incremental Marking 算法，即增量标记算法。将标记过程细分为小的子标记过程，让 GC 标记与 JavaScript 应用逻辑交替进行，直到标记阶段完成。</p><p>将大任务分割成小任务，小任务执行时间短，穿插在 JavaScript 任务中执行，从而尽可能减少卡顿现象。这个设计思路与 React Fiber 很像。</p><h4 id="早期的-gc-机制-引用计数" tabindex="-1"><a class="header-anchor" href="#早期的-gc-机制-引用计数" aria-hidden="true">#</a> 早期的 GC 机制 - 引用计数</h4><p>引擎维护一张引用表，保存内存里资源的引用次数，如果一个资源的引用次数为 0，则表示该资源内存可以被回收。</p><p>由于这个机制的缺点是不能回收循环引用，因此被废弃。</p><h3 id="内存泄露-memory-leak" tabindex="-1"><a class="header-anchor" href="#内存泄露-memory-leak" aria-hidden="true">#</a> 内存泄露(Memory leak)</h3><p>当不在用到的对象内存没有及时被回收时，我们称为内存泄露。</p><h4 id="原因" tabindex="-1"><a class="header-anchor" href="#原因" aria-hidden="true">#</a> 原因</h4><ol><li>数据缓存大小超限；</li><li>浏览器队列消费不及时，导致一些作用域变量不能及时释放；</li><li>隐式全局变量。意外定义了全局变量。最好规范定义变量；</li><li>定时器引用未清除；</li><li>不正确的使用闭包。闭包内变量的间接/错误引用；</li><li>事件重复监听；</li><li>未清理的 <code>console</code> 输出，也可能造成内存泄露。</li></ol><h4 id="避免内存泄露的方法" tabindex="-1"><a class="header-anchor" href="#避免内存泄露的方法" aria-hidden="true">#</a> 避免内存泄露的方法</h4><ol><li>尽量减少全局变量的使用，避免意外定义全局变量；</li><li>闭包内的变量引用(如 Dom 元素)，要及时清理；</li><li>定时器引用及时清除；</li><li>使用 <code>WeakSet</code> 和 <code>Weakmap</code> 结构，它们都是弱引用，不影响 GC 机制；</li><li>生成环境，及时清理 <code>console</code> 输出。</li></ol>',30),o=[l];function t(d,h){return e(),r("div",null,o)}const p=a(c,[["render",t],["__file","gc.html.vue"]]);export{p as default};
